# Find first unique

https://jbt.github.io/markdown-editor/#pZHNDoIwEITv+xSTcNHEC38h8ebFxIsXXwCkRZrAFksbX9+C+O+FeGi22enMfm0DbBULVMr0Fo7V2Umwa4/SEO24c3aNPEKCCJlfIVK/z3y99eKcKAgCHKzsEBLttZBD/en0Z7cvY7yc5FhcjObTkmjTNJPQD8o4JPW6KVjoFtoIaVYQspMsemhGXfQ1KselVZqnAOG6RpWFHTOiOe6RPHqSf97yHW/Q4r/gfO4c/+ORvxDvHzJA0hU=

https://jbt.github.io/markdown-editor/#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

# Find smallest unique

## Problem statement

- N players pick a number
- The player who picked the *smallest number* that *nobody else picked* wins

## Interview steps

What is known
- number of players **N** (= size of the array)
- number of threads/nodes (100)

Steps

- single-node solution (sort-based)
- any improvement? (hashmap-based)
- what if N is **very large**?

Competencies

- hash functions and application outside of a hash map
- hash maps
- sorting
- how to distribute load across nodes
- some idea of multi threading


## Single-node solution

1. sort the input `O(n * log n)`
1. find the smallest unique `O(n)`

Complexity: `O(n * log n)`

### Single-node solution (better)

1. iterate through the array and count occurrence using a hash map `O(n)`
3. iterate through the hash map and return the smallest unique `O(m)`, where `m <= n`

Complexity: `O(n)`

## Distributed solution

Problem
- 100 nodes are available to speed up the solution
- each node receives a *reference* to the input
- nodes can send each other data

APIs
- `int MyNodeId()`
- `int NumberOfNodes()`
- `void Send(int nodeId, int data)` non-blocking
- `int Receive()` blocking

### Considerations

- Not enough if each node sends their locally smallest unique
  - what if all numbers are the same?
- Not enough if each node sends all their locally unique numbers
  - risk of false positive (a locally unique number might not be globally unique)
  - e.g. node 1: `1 2 3`, node 2: `1 3 4`, right answer: `2`, not `1`
- Not enough to send all unique + all duplicates **to 1 node**
  - what if all numbers are unique? that node would be overwhelmed
- Problems with using **modulo** to assign numbers to nodes
  - what if all numbers are multiple of the modulo (end up in the same node)

## Example

Input: `2 4 2 7 2 1 3 4 7 1 2 2 5`

Answer: `3`

### Step 1

---

Each node
- takes a portion of the input
- sorts it
- and outputs a list of numbers where the duplicates are repeated only twice

---

#### Node 1

Input: `2 4 2 7 2 1 3`

After sorting: `1 2 2 2 3 4 7`

Output: `1 2 2 3 4 7` (duplicates kept only twice)

Complexity: `O(n * log n)`

#### Node 2

Input: `4 7 1 2 2 5`

After sorting: `1 2 2 4 5 7`

Output: `1 2 2 4 5 7` (duplicates kept only twice)

Complexity: `O(n * log n)`

#### Can sorting be avoided for this step?

Input: `2 4 2 7 2 1 3`

Construct hash table:

```
map: number -> count
{
  2 -> 3
  4 -> 1
  7 -> 1
  1 -> 1
  3 -> 1
}
```

Output: `4 1  7 2 2 3` (random order, depends on hash function)

Complexity
- generate map: `O(n)` 
- iterate map:  `O(m)`, where `m <= n`
- generate output: `O(m)`
- **Overall**: `O(n)`

When better: if `log n > 3` (i.e. when approx. `n > 10`)


### Step 2

---

Hash function (used to dispatch a list of numbers to each node)

E.g.
- Node 1: `[1 2 3]` (i.e., all the 1s, all the 2s, all the 3s)
- Node 2: `[4 5 7]`

Complexity: `O(n)`

---

### Step 3

---

Each node
- sorts the input
- outputs the list of unique numbers

---

#### Node 1

Responsible for: `1 2 3`

Input: `1 2 2 2 3 1 2 2`

Output: `3` (only unique numbers)

Complexity: `O(n * log n)`

#### Node 2

Responsible for: `4 5 7`

Input: `4 7 4 5 7`

Ouput: `5` (only unique numbers)

Complexity: `O(n * log n)`

### Step 4

---

Master node
- finds the smallest unique

---

#### Master node

Input: `3 5`

Output: `3`

Complexity: `O(n * log n)`

#### Pseudo code

```python
# N: length of the array
# Node 0: [0, N / NumberOfNodes() - 1]
# Node 1: [N / NumberOfNodes(), 2 * N / NumberOfNodes() - 1]
k = MyNodeId()
input = Numbers[k * N / NumberOfNodes() : (k + 1) * N / NumberOfNodes() - 1]
sort(input)
for n in input:
  #discards any occurrence of a number appearing more than 2 times
for n in input:
  nodeToSend = n % NumberOfNodes() #better: use a hash function
  Send(nodeToSend, n) # Send(nodeId, data)
...
```

  
